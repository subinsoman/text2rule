package com.sixdee.text2rule.workflow;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.sixdee.text2rule.agent.ActionExtractionAgent;
import com.sixdee.text2rule.agent.ConsistencyAgent;
import com.sixdee.text2rule.agent.DecompositionAgent;
import com.sixdee.text2rule.agent.PromptRefinementAgent;
import com.sixdee.text2rule.agent.SegmentExtractionAgent;
import com.sixdee.text2rule.agent.ValidationAgent;
import com.sixdee.text2rule.config.PromptRegistry;
import com.sixdee.text2rule.dto.DecompositionResult;
import com.sixdee.text2rule.model.NodeData;
import com.sixdee.text2rule.model.RuleNode;
import com.sixdee.text2rule.model.RuleTree;
import dev.langchain4j.model.chat.ChatLanguageModel;
import org.bsc.langgraph4j.CompiledGraph;
import org.bsc.langgraph4j.GraphRepresentation;
import org.bsc.langgraph4j.StateGraph;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

import static org.bsc.langgraph4j.StateGraph.END;
import static org.bsc.langgraph4j.StateGraph.START;

public class AgenticConversionWorkflow {
    private static final Logger logger = LoggerFactory.getLogger(AgenticConversionWorkflow.class);
    private static final String CONSISTENCY_PROMPT_KEY = "consistency_check_prompt";
    private static final String DEFAULT_SYSTEM_PROMPT = "You are a rule decomposition expert. Your goal is to decompose the input statement into a valid rule structure.\n"
            +
            "Use the available tools. Follow this process:\n" +
            "1. Analyze the input statement and decompose it into a structured format.\n" +
            "   Required Fields:\n" +
            "   - 'normal_statements': A complete, standalone rule statement that includes conditions, actions, bonus, policy, and sampling logic. Each statement must be logically isolated and self-contained.\n"
            +
            "   - 'schedule': A single, separate scheduling instruction for when the campaign should run, extracted independently from the input statement. Leave empty if no schedule is specified.\n"
            +
            "   - 'input_text': The original input.\n" +
            "2. Call 'submitDecomposition' with this EXACT structure. Do NOT invent new fields.\n" +
            "3. Call 'checkConsistency' with the returned JSON and original input.\n" +
            "4. If consistency status is 'PASS', output ONLY the decomposition JSON as your final answer.\n" +
            "5. If status is 'FAIL', examine the feedback/score and retry by adjusting your structure and calling 'submitDecomposition' again.\n"
            +
            "6. Repeat until PASS. If it fails repeatedly, apologize and output the best attempt JSON.\n" +
            "IMPORTANT: Your final answer must be a valid JSON block.";

    private final ValidationAgent validationAgent;
    private final DecompositionAgent decompositionAgent;
    private final ConsistencyAgent consistencyAgent;
    private final PromptRefinementAgent promptRefinementAgent;
    private final SegmentExtractionAgent segmentAgent;
    private final ActionExtractionAgent actionAgent;
    private final ObjectMapper objectMapper;
    private final double consistencyThreshold;
    private final int maxRetries;
    private CompiledGraph<WorkflowState> compiledGraph;

    public AgenticConversionWorkflow(ChatLanguageModel lang4jService) {
        this.validationAgent = new ValidationAgent(lang4jService);
        this.decompositionAgent = new DecompositionAgent(lang4jService);
        this.consistencyAgent = new ConsistencyAgent(lang4jService);
        this.promptRefinementAgent = new PromptRefinementAgent(lang4jService);
        this.segmentAgent = new SegmentExtractionAgent(lang4jService);
        this.actionAgent = new ActionExtractionAgent(lang4jService);
        this.objectMapper = new ObjectMapper();

        // Read configuration from prompts.xml
        PromptRegistry registry = PromptRegistry.getInstance();
        String thresholdStr = registry.getAttribute(CONSISTENCY_PROMPT_KEY, "consistency_threshold");
        String maxRetriesStr = registry.getAttribute(CONSISTENCY_PROMPT_KEY, "max_retries");

        this.consistencyThreshold = thresholdStr != null ? Double.parseDouble(thresholdStr) : 0.8;
        this.maxRetries = maxRetriesStr != null ? Integer.parseInt(maxRetriesStr) : 3;

        logger.info("AgenticConversionWorkflow initialized with consistency_threshold={}, max_retries={}",
                consistencyThreshold, maxRetries);
    }

    public CompiledGraph<WorkflowState> build() throws Exception {
        StateGraph<WorkflowState> workflow = new StateGraph<>(WorkflowState::new);

        // Add all nodes
        workflow.addNode("validate_agent", this::validateNode);
        workflow.addNode("decompose_agent", this::decomposeNode);
        workflow.addNode("consistency_check", this::consistencyCheckNode);
        workflow.addNode("refine_prompt", this::refinePromptNode);
        workflow.addNode("segment_agent", this::segmentNode);
        workflow.addNode("action_agent", this::actionNode);

        // Start with validation
        workflow.addEdge(START, "validate_agent");

        // After validation, decide whether to proceed or end
        workflow.addConditionalEdges(
                "validate_agent",
                state -> {
                    boolean valid = "true".equalsIgnoreCase((String) state.data().getOrDefault("valid", "false"));
                    if (valid) {
                        return CompletableFuture.completedFuture("decompose_agent");
                    } else {
                        return CompletableFuture.completedFuture(END);
                    }
                },
                Map.of("decompose_agent", "decompose_agent", END, END));

        // After decomposition, always check consistency
        workflow.addConditionalEdges(
                "decompose_agent",
                state -> {
                    if (state.isWorkflowFailed())
                        return CompletableFuture.completedFuture(END);
                    return CompletableFuture.completedFuture("consistency_check");
                },
                Map.of("consistency_check", "consistency_check", END, END));

        // After consistency check, decide: pass → segment, fail → refine or end
        workflow.addConditionalEdges(
                "consistency_check",
                state -> {
                    if (state.isWorkflowFailed()) {
                        return CompletableFuture.completedFuture(END);
                    }

                    Double score = state.getConsistencyScore();
                    int retryCount = state.getRetryCount();

                    // PASS: score >= threshold
                    if (score != null && score >= consistencyThreshold) {
                        logger.info("✓ Consistency PASSED (score={}, threshold={}). Proceeding to segment extraction.",
                                score, consistencyThreshold);
                        return CompletableFuture.completedFuture("segment_agent");
                    }

                    // FAIL: check if we can retry
                    if (retryCount >= maxRetries) {
                        logger.warn("✗ Max retries ({}) reached with score={}. Proceeding despite failure.",
                                maxRetries, score);
                        return CompletableFuture.completedFuture("segment_agent");
                    }

                    // RETRY: refine prompt and try again
                    logger.info("✗ Consistency FAILED (score={}, threshold={}). Retry {}/{}. Refining prompt...",
                            score, consistencyThreshold, retryCount + 1, maxRetries);
                    return CompletableFuture.completedFuture("refine_prompt");
                },
                Map.of("segment_agent", "segment_agent", "refine_prompt", "refine_prompt", END, END));

        // After prompt refinement, loop back to decomposition
        workflow.addEdge("refine_prompt", "decompose_agent");

        // Segment agent flow
        workflow.addConditionalEdges(
                "segment_agent",
                state -> {
                    if (state.isWorkflowFailed())
                        return CompletableFuture.completedFuture(END);
                    return CompletableFuture.completedFuture("action_agent");
                },
                Map.of("action_agent", "action_agent", END, END));

        // Action agent ends the workflow
        workflow.addEdge("action_agent", END);

        this.compiledGraph = workflow.compile();
        return this.compiledGraph;
    }

    private CompletableFuture<Map<String, Object>> validateNode(WorkflowState state) {
        logger.info("Calling Validation Agent...");
        return validationAgent.execute(state.getInput())
                .thenApply(agentState -> Map.of(
                        "validationResponse", agentState.getValidationResult(),
                        "valid", String.valueOf(agentState.isValid())));
    }

    private CompletableFuture<Map<String, Object>> decomposeNode(WorkflowState state) {
        int retryCount = state.getRetryCount();
        logger.info("═══ DECOMPOSITION AGENT (Attempt {}/{}) ═══", retryCount + 1, maxRetries + 1);

        // Use custom prompt if available, otherwise use default
        String systemPrompt = state.getCurrentDecompositionPrompt();
        if (systemPrompt == null || systemPrompt.trim().isEmpty()) {
            systemPrompt = DEFAULT_SYSTEM_PROMPT;
            logger.info("Using default system prompt");
        } else {
            logger.info("Using refined system prompt from previous iteration");
        }

        return decompositionAgent.execute(state.getInput(), systemPrompt)
                .thenApply(agentState -> {
                    if (agentState.isFailed()) {
                        return Map.of("workflowFailed", true, "failureReason", "Decomposition Agent Failed");
                    }
                    DecompositionResult result = agentState.getDecompositionResult();
                    RuleTree<NodeData> tree = agentState.getTree();

                    if (result == null || tree == null) {
                        return Map.of("workflowFailed", true, "failureReason",
                                "Decomposition Agent produced null result or tree");
                    }

                    logger.info("Decomposition completed successfully");

                    // Store previous output for prompt refinement
                    String previousOutput = "";
                    try {
                        previousOutput = objectMapper.writeValueAsString(result);
                    } catch (Exception e) {
                        logger.warn("Failed to serialize decomposition result", e);
                    }

                    return Map.of(
                            "decompositionResponse", result,
                            "tree", tree,
                            "previousOutput", previousOutput);
                });
    }

    private CompletableFuture<Map<String, Object>> consistencyCheckNode(WorkflowState state) {
        logger.info("═══ CONSISTENCY CHECK AGENT ═══");
        RuleTree<NodeData> tree = state.getTree();

        if (tree == null) {
            logger.error("Tree is null, cannot check consistency");
            return CompletableFuture.completedFuture(Map.of("workflowFailed", true));
        }

        return consistencyAgent.execute(tree, "root")
                .thenApply(consistencyState -> {
                    Double score = consistencyState.getConsistencyScore();

                    if (score == null) {
                        logger.warn("Consistency check returned null score, defaulting to 0.0");
                        score = 0.0;
                    }

                    logger.info("Consistency score: {}", score);

                    // Generate detailed feedback for prompt refinement
                    String feedback = generateFeedback(tree, score);

                    return Map.of(
                            "consistencyScore", score,
                            "feedback", feedback);
                });
    }

    private CompletableFuture<Map<String, Object>> refinePromptNode(WorkflowState state) {
        int currentRetry = state.getRetryCount();
        logger.info("═══ PROMPT REFINEMENT AGENT (Retry {}/{}) ═══", currentRetry + 1, maxRetries);

        String originalPrompt = state.getCurrentDecompositionPrompt();
        if (originalPrompt == null || originalPrompt.trim().isEmpty()) {
            originalPrompt = DEFAULT_SYSTEM_PROMPT;
        }

        String inputText = state.getInput();
        String previousOutput = state.getPreviousOutput();
        String feedback = state.getFeedback();

        String refinedPrompt = promptRefinementAgent.refinePrompt(originalPrompt, inputText, previousOutput, feedback);

        if (refinedPrompt == null || refinedPrompt.trim().isEmpty()) {
            logger.warn("Prompt refinement failed, keeping original prompt");
            refinedPrompt = originalPrompt;
        } else {
            logger.info("Successfully generated refined prompt");
        }

        return CompletableFuture.completedFuture(Map.of(
                "currentDecompositionPrompt", refinedPrompt,
                "retryCount", currentRetry + 1));
    }

    private String generateFeedback(RuleTree<NodeData> tree, Double score) {
        StringBuilder feedback = new StringBuilder();
        feedback.append("Consistency Score: ").append(String.format("%.2f", score));
        feedback.append(" (Threshold: ").append(consistencyThreshold).append(")\n\n");

        if (score < consistencyThreshold) {
            feedback.append("The decomposition does not adequately preserve the original statement's meaning.\n\n");

            // Collect original and children text for detailed analysis
            RuleNode<NodeData> root = tree.getRoot();
            String originalText = root.getData().getInput();
            List<String> childrenTexts = new ArrayList<>();
            for (RuleNode<NodeData> child : root.getChildren()) {
                childrenTexts.add(child.getData().getInput());
            }

            feedback.append("Original Text:\n").append(originalText).append("\n\n");
            feedback.append("Decomposed Children:\n");
            for (int i = 0; i < childrenTexts.size(); i++) {
                feedback.append((i + 1)).append(". ").append(childrenTexts.get(i)).append("\n");
            }
            feedback.append("\n");

            feedback.append("Issues Detected:\n");
            if (score < 0.5) {
                feedback.append("- Major semantic differences between original and decomposed statements\n");
                feedback.append("- Critical information may be missing or incorrectly split\n");
            } else if (score < 0.7) {
                feedback.append("- Moderate semantic differences detected\n");
                feedback.append("- Some details may be lost or incorrectly categorized\n");
            } else {
                feedback.append("- Minor inconsistencies in decomposition\n");
                feedback.append("- Fine-tune the splitting logic to better preserve context\n");
            }

            feedback.append("\nSuggestions:\n");
            feedback.append("- Ensure all conditions, actions, bonuses, and policies are fully captured\n");
            feedback.append("- Verify that schedule information is correctly separated\n");
            feedback.append("- Check that normal_statements is a single cohesive string\n");
        }

        return feedback.toString();
    }

    private CompletableFuture<Map<String, Object>> segmentNode(WorkflowState state) {
        logger.info("Calling Segment Extraction Agent...");
        RuleTree<NodeData> tree = state.getTree();
        return segmentAgent.execute(tree)
                .thenApply(agentState -> {
                    if (agentState.isFailed()) {
                        return Map.of("workflowFailed", true, "failureReason", "Segment Agent Failed");
                    }
                    return Map.of("tree", agentState.getTree());
                });
    }

    private CompletableFuture<Map<String, Object>> actionNode(WorkflowState state) {
        logger.info("Calling Action Extraction Agent...");
        RuleTree<NodeData> tree = state.getTree();
        return actionAgent.execute(tree)
                .thenApply(agentState -> {
                    if (agentState.isFailed()) {
                        return Map.of("workflowFailed", true);
                    }
                    return Map.of("tree", agentState.getTree());
                });
    }

    public String print() {
        try {
            if (this.compiledGraph == null) {
                throw new IllegalStateException("Workflow graph must be built before printing.");
            }
            GraphRepresentation graphRep = this.compiledGraph.getGraph(GraphRepresentation.Type.MERMAID);
            return graphRep.getContent();
        } catch (Exception e) {
            logger.error("Error printing graph", e);
            throw new RuntimeException(e);
        }
    }
}
